mysql查询操作流程  客户端 -》 连接器 -》 分析器 -》 优化器 -》 执行器 -》 存储引擎（InnoDB、MyISAM、Memory）
mysql更新操作流程  innodb有redolog的日志记录， binlog是mysql的server层共有的和存储层没有关系 
                  redolog相当于暂时存储更新数据（有存储更新sql和存储数据变化前后两条数据）日志  binlog是存储了所有的更新操作的日志，写在磁盘上 
两阶段的提交 （保持两个日志的数据一致性） 
1.执行器先找引擎取ID=2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。
2.执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据。
3.引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。
4.执行器生成这个操作的binlog，并把binlog写入磁盘。
5.执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。


不同事务隔离级别的区别：
读未提交：一个事务还未提交，它所做的变更就可以被别的事务看到
读提交：一个事务提交之后，它所做的变更才可以被别的事务看到
可重复读：一个事务执行过程中看到的数据是一致的。未提交的更改对其他事务是不可见的
串行化：对应一个记录会加读写锁，出现冲突的时候，后访问的事务必须等前一个事务执行完成才能继续执行
1、事务隔离的实现：每条记录在更新的时候都会同时记录一条回滚操作。同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制（MVCC）。
2、回滚日志什么时候删除？系统会判断当没有事务需要用到这些回滚日志的时候，回滚日志会被删除。
3、什么时候不需要了？当系统里么有比这个回滚日志更早的read-view的时候。
4、为什么尽量不要使用长事务。长事务意味着系统里面会存在很老的事务视图，在这个事务提交之前，回滚记录都要保留，这会导致大量占用存储空间。除此之外，长事务还占用锁资源，可能会拖垮库。
5、事务启动方式：一、显式启动事务语句，begin或者start transaction,提交commit，回滚rollback；二、set autocommit=0，该命令会把这个线程的自动提交关掉。这样只要执行一个select语句，事务就启动，并不会自动提交，直到主动执行commit或rollback或断开连接。
6、建议使用方法一，如果考虑多一次交互问题，可以使用commit work and chain语法。在autocommit=1的情况下用begin显式启动事务，如果执行commit则提交事务。如果执行commit work and chain则提交事务并自动启动下一个事务。










数据库事务  ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）   
分布式系统  Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。

StringBuffer  支持并发操作，线性安全的，适合多线程中使用。
StringBuilder 不支持并发操作，线性不安全的，不适合多线程中使用，但其在单线程中的性能比StringBuffer高。
